
-------------------------------------------------------------------------------------------------
Basic Setup
------------------------------------------------------------------------------------------------
Code First approach.

1) create project

2) install required packages for EF core
using nuget package manager console or dotnet cli
- dotnet add package Microsoft.EntityFrameworkCore.SqlServer
- dotnet add package Microsoft.EntityFrameworkCore.Tools
- dotnet add package Microsoft.EntityFrameworkCore.Design

3) create models 
- models may have one to many many to many realtionships check models for details

4) create DbContext best practice is to create inside Data folder Data > ApplicationDBContext.cs
- create a class that inherits from DbContext
- define DbSet properties for each model

 public ApplicationDBContext(DbContextOptions options) : base(options)
        {


        }
        public DbSet<Model> Stocks { get; set; } -> like this reguiter your models
	}
}

5) register DbContext in Program.cs

   builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

6) add connection string in appsettings.json file 

"ConnectionStrings": {
  "anyName": "Server=YOUR_MACHINE_NAME\\SQLEXPRESS;Database=YOUR_DATABASE_NAME;Trusted_Connection=True;TrustServerCertificate=True;"
}

7) create migrations
use package manager console or dotnet cli
- dotnet ef migrations add InitialCreate
or in package manager console
- Add-Migration InitialCreate -> or any name you want

it will create tables in your database based on your models

8) update database
use package manager console or dotnet cli
- dotnet ef database update
or in package manager console
- Update-Database

9) create Repositories

-  repository is a design pattern that separates your business logic (like controllers or services) from the data access logic (like EF Core, SQL queries) (CRUD operations).

- create a folder Interfaces > IAnyNameRepository.cs

- define the interface with methods for CRUD operations, e.g.,

* Task<Stock> CreateAsync(Stock stock); 

- create a folder  Repositories > AnyNameRepository.cs

-  inject the DbContext in the repository constructor eg:

private readonly ApplicationDBContext _context;

        // injection
        public StockRepository(ApplicationDBContext context)
        {
            _context = context;
        }

- implement the interface in the repository class by inheriting from it

- implement all metods defined in the interface

- Note:
* use async methods for better performance
* make sure if you have multiple repositories, you can inject the DbContext in each repository constructor

10) register repositories in Program.cs

- builder.Services.AddScoped<IAnyNameRepository,AnyRepository>();
- Note: Make sure to register all repositories you created

11) create controllers
- create a folder Controllers > AnyNameController.cs
- right click on Controllers folder and add a new controller 
- inject the repository in the controller constructor make sure inject the interface not the concrete class
- define the controller methods for CRUD operations
- use async methods for better performance
- check Controllers > StockController.cs for details
- also check StockRepository.cs for details on how to implement CRUD operations
- use [FromBody] attribute to bind the request body to the model in POST and PUT methods
------------------------------------------------------------------------------------------------
Generalized CRUD operations for EntityController and Repository may change a/c to your needs
------------------------------------------------------------------------------------------------


public interface IEntityRepository
{
    Task<List<Entity>> GetAllAsync();
    Task<Entity?> GetByIdAsync(int id);
    Task<Entity> CreateAsync(Entity entity);
    Task<Entity?> UpdateAsync(Entity entity);
    Task<Entity?> DeleteAsync(int id);
    Task<bool> ExistsAsync(int id);
}
-----------------------------------------------------------------------------------------
public class EntityRepository : IEntityRepository
{
    private readonly ApplicationDBContext _context;

    public EntityRepository(ApplicationDBContext context)
    {
        _context = context;
    }

    public async Task<List<Entity>> GetAllAsync()
    {
        return await _context.Entities.ToListAsync();
    }

    public async Task<Entity?> GetByIdAsync(int id)
    {
        return await _context.Entities.FindAsync(id);
    }

    public async Task<Entity> CreateAsync(Entity entity)
    {
        await _context.Entities.AddAsync(entity);
        await _context.SaveChangesAsync();
        return entity;
    }

    public async Task<Entity?> UpdateAsync(Entity entity)
    {
        var exists = await _context.Entities.AnyAsync(e => e.Id == entity.Id);
        if (!exists) return null;

        _context.Entities.Update(entity);
        await _context.SaveChangesAsync();
        return entity;
    }

    public async Task<Entity?> DeleteAsync(int id)
    {
        var entity = await _context.Entities.FindAsync(id);
        if (entity == null) return null;

        _context.Entities.Remove(entity);
        await _context.SaveChangesAsync();
        return entity;
    }

    public async Task<bool> ExistsAsync(int id)
    {
        return await _context.Entities.AnyAsync(e => e.Id == id);
    }


-----------------------------------------------------------------------------------------

[Route("api/[controller]")]
[ApiController]
public class EntityController : ControllerBase
{
    private readonly IEntityRepository _entityRepo;

    public EntityController(IEntityRepository entityRepo)
    {
        _entityRepo = entityRepo;
    }

    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        var data = await _entityRepo.GetAllAsync();
        return Ok(data);
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(int id)
    {
        var entity = await _entityRepo.GetByIdAsync(id);
        if (entity == null) return NotFound("Entity not found");
        return Ok(entity);
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] Entity entity)
    {
        if (!ModelState.IsValid) return BadRequest(ModelState);

        var created = await _entityRepo.CreateAsync(entity);
        return CreatedAtAction(nameof(GetById), new { id = created.Id }, created);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, [FromBody] Entity entity)
    {
        if (!ModelState.IsValid) return BadRequest(ModelState);
        if (id != entity.Id) return BadRequest("ID mismatch");

        var updated = await _entityRepo.UpdateAsync(entity);
        if (updated == null) return NotFound("Entity not found");

        return Ok(updated);
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete(int id)
    {
        var deleted = await _entityRepo.DeleteAsync(id);
        if (deleted == null) return NotFound("Entity not found");
        return NoContent();
    }
}

------------------------------------------------------------------------------------------
DTO (Data Transfer Object)
------------------------------------------------------------------------------------------
DTO ka Basic Maqsad:

- Data Transfer Only:
DTO sirf data transfer karne ke liye hoti hai — frontend se backend ya backend se frontend.

- Security:
Sensitive fields (e.g., PasswordHash, InternalId) ko hide karna.

- Custom Fields:
Sirf required fields bhejna — unnecessary fields skip karna.

- Validation:
DTOs me [Required], [Range] jaise validation attributes laga sakte ho.

- Loose Coupling:
Model change hone par client break nahi hota — DTO ne dependency reduce ki hoti hai.


eg:

Entity Model (e.g., User Entity)

public class User
{
    public int Id { get; set; }
    public string FullName { get; set; }
    public string Email { get; set; }
    public string PasswordHash { get; set; }
    public DateTime CreatedAt { get; set; }
    public bool IsAdmin { get; set; }
}

DTO (e.g., UserDto)

public class UserDto
{
    public string FullName { get; set; }
    public string Email { get; set; }
}

- hmny yahan sy extra cheezen hta di
- Note: check StockDto,StockModel,CmmentDto,CommentModel for details 
------------------------------------------------------------------------------------------
Mappers
------------------------------------------------------------------------------------------public static class EntityMapper
{
    // Model -> DTO

public static class [ModelName]Mappers
{
    public static [DtoName] To[DtoName](this [ModelName] modelObject)
    {
        return new [DtoName]
        {
            Property1 = modelObject.Property1,
            Property2 = modelObject.Property2,
            // ... Add more as needed
        };
    }
}


    // DTO -> Model //jb frontend se data a ra ho

    public static class [ModelName]Mappers
{
    public static [ModelName] To[ModelName](this [DtoName] dtoObject)
    {
        return new [ModelName]
        {
            Property1 = dtoObject.Property1,
            Property2 = dtoObject.Property2,
            // ... Add more
        };
    }
}

// update Dto

       public static void UpdateFromDto(this [ModelName] modelObject, Update[ModelName]RequestDto dtoObject)
        {
            modelObject.Property1 = dtoObject.Property1;
            modelObject.Property2 = dtoObject.Property2;
            // ... Add more fields to update
        }
    }
}




Mapper ka Kaam Kya Hai?
- Mapper = bridge between Model <-> DTO
- Ye kaam tum manually karo ya AutoMapper se
- Large projects mein 
- AutoMapper time bachata hai
* then make changes in controllers see controller for details

Note: 
- make sure the method and class must be static
- check Mappers > StockMappers.cs, CommentMappers.cs for details
- install required packages
* Newtonsoft.Json //latest version
* Microsoft.AspNetCore.Mvc.NewtonsoftJson

- make changes in program .cs:

 builder.Services.AddControllers().AddNewtonsoftJson(options =>
{
    options.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;
});

- some info about why we use this packages:

Newtonsoft.Json circular references (jaise Stock → Comments → Stock) handle karne ke liye install karte hain.

Default JSON serializer (System.Text.Json) circular loop pe error deta hai.

Jab models mein navigation properties hoon, tab Newtonsoft.Json use karna chahiye.

ReferenceLoopHandling.Ignore se JSON infinite loop skip kar deta hai aur API crash nahi hoti.

Newtonsoft.Json circular references (jaise Stock → Comments → Stock) handle karne ke liye install karte hain.

Default JSON serializer (System.Text.Json) circular loop pe error deta hai.

Jab models mein navigation properties hoon, tab Newtonsoft.Json use karna chahiye.

ReferenceLoopHandling.Ignore se JSON infinite loop skip kar deta hai aur API crash nahi hoti.

------------------------------------------------------------------------------------------
Models validations
------------------------------------------------------------------------------------------
- validations you can cretae in models directly and dtos also 

- best practice is to use table etc atrributes in models and required min max length etc in dtos 
- check Dtos and Models folder for details
- some examples:


   [Table("Portfolios")] // Ye table ka naam hai jo database mein banega many to many lazmi name do wrna wo and shnd bna dega nam

    public class Portfolio
  
   {
        //properties
        public string AppUserId { get; set; }
        public int StockId { get; set; }

        //attributes
        [Column(TypeName = "decimal(18,2)")] // it accepts total  max 18 digits, with 2 decimal (16 before . 2 after .) places eg: 100.00,
        public decimal LastDiv { get; set; }

        [Required]
        [MinLength(5, ErrorMessage = "Title must be 5 characters")]
        [MaxLength(280, ErrorMessage = "Title can not be over 280 characters")]
        public string Title { get; set; } = string.Empty;
       
    }

note:
- to use validations 

 [HttpGet("{id:int}")]
        public async Task<IActionResult> GetById(int id)
        {
        //use this 
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState); // to get all validation errors we provided in dtos
            }

            //other logic

    
        }

------------------------------------------------------------------------------------------
Filtering
------------------------------------------------------------------------------------------
- Purpose of Filtering in APIs:
- Improves performance by fetching only the required data instead of the entire dataset.
- Provides flexibility for users to search or narrow results (e.g., by CompanyName or Symbol).
- Reduces data transfer by sending only necessary information over the network.
- Ensures scalability by handling large datasets efficiently without slowing down the system.
- we use query parameters 

Step 1: Create QueryObject Class


 File: Helpers/QueryObject.cs

Code:
-----------------------------------------
namespace YourProject.Helpers
{
    public class QueryObject
    {
        public string? CompanyName { get; set; }
        public string? Symbol { get; set; }
    }
}
-----------------------------------------

 Explanation:
- Yeh ek simple class hai jo query string values ko capture karegi.
- Agar user request kare `/api/stock?CompanyName=Tesla`, to `CompanyName` property mein "Tesla" store ho jayega.
- Yeh class controller mein [FromQuery] ke through automatically fill hoti hai.


Step 2: Modify IStockRepository Interface


 File: Interfaces/IStockRepository.cs

Code:
-----------------------------------------
Task<List<Stock>> GetAllAsync(QueryObject query);
-----------------------------------------

 Explanation:
- Yeh method interface mein define kiya gaya hai taake har class jo IStockRepository implement kare, usme yeh method lazmi ho.
- Is method ka kaam filtered stocks list dena hoga based on `QueryObject`.


Step 3: Implement Filtering in Repository


 File: Repositories/StockRepository.cs

Code:
-----------------------------------------
public async Task<List<Stock>> GetAllAsync(QueryObject query)
{
    var stocks = _context.Stocks.Include(s => s.Comments).AsQueryable();

    if (!string.IsNullOrWhiteSpace(query.CompanyName))
    {
        stocks = stocks.Where(s => s.CompanyName.Contains(query.CompanyName));
    }

    if (!string.IsNullOrWhiteSpace(query.Symbol))
    {
        stocks = stocks.Where(s => s.Symbol.Contains(query.Symbol));
    }

    return await stocks.ToListAsync();
}
-----------------------------------------

 Explanation:
- `_context.Stocks.Include(...)`: Yeh database se stocks ke sath comments bhi la raha hai.
- `.AsQueryable()`: Is se hum query ko dynamic bana sakte hain aur filters runtime pe add kar sakte hain.
- `Where(...)`: Filter lagaya gaya hai agar `CompanyName` ya `Symbol` provided ho.
- `ToListAsync()`: Final query ab SQL server pe chali jayegi aur result memory mein load hoga.


Step 4: Accept Filters in Controller


 File: Controllers/StockController.cs

Code:
-----------------------------------------
[HttpGet]
public async Task<IActionResult> GetAll([FromQuery] QueryObject query)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);

    var stocks = await _stockRepo.GetAllAsync(query);
    var stockDtos = stocks.Select(s => s.ToStockDto());

    return Ok(stockDtos);
}
-----------------------------------------

 Explanation:
- `[FromQuery]`: Yeh batata hai ASP.NET ko ke query string values `QueryObject` mein map karni hain.
- `GetAllAsync(query)`: Repository method call hoti hai jo filtered data return karegi.
- `ToStockDto()`: Yeh method stock ko DTO (Data Transfer Object) mein convert karta hai taake frontend ko sirf zaroori data mile.


Step 5: Test with Postman or Browser


Examples:
-----------------------------------------
GET /api/stock?CompanyName=Apple
GET /api/stock?Symbol=AAPL
GET /api/stock?CompanyName=Tesla&Symbol=TSLA
-----------------------------------------

 Explanation:
- Tum GET request mein query string de kar filter apply kar sakte ho.
- Yeh query `QueryObject` mein map hoti hai aur DB pe filter apply hota hai.






--------------------------********* comment filter for learning purposes ***----

now when we get al comments we will get the comments that are not filtered
-> we want to filter the comments by symbol
-> sort comment by newest
-> like this using query parameters

http://localhost:3453/api/comment?Symbol=tsla&lsDecsending=true 


Step 1: Create QueryObject Class


 File: Helpers/CommentQueryObject.cs
-> check for details

step 2: modify Commentcontroller 
check GetAll for details

step 3: 
modify ICommentRepository to accept the query object

step 4: modify CommentRepository to accept the query object

step 5 in CommentRepository.cs 
modify GetAllAsync 

replace this 
      return await _context.Comments.Include(a => a.AppUser).ToListAsync();


      with this

       var comments =  _context.Comments.Include(a => a.AppUser).AsQueryable();

            if (!string.IsNullOrEmpty(commentQueryObject.Symbol))
            {

                // only comments related to this stock
                comments = comments.Where(s => s.Stock.Symbol == commentQueryObject.Symbol);

            }
            if (commentQueryObject.IsDecsending == true)
            {
                comments = comments.OrderByDescending(c => c.CreatedOn);
            }



            return await comments.ToListAsync();

            //cors setup
            in program .cs


            //  CORS middleware configure kar rahe hain
app.UseCors(x => x

    //  Agar tum chahte ho ke sirf PUT requests allow hon
    // To AllowAnyMethod() ki jagah Use karo:
    // .WithMethods("PUT") // sirf PUT allow hoga
    .AllowAnyMethod() // <-- Ye sab methods allow karega (GET, POST, PUT, DELETE, etc.)

    //  Agar tum chahte ho ke sirf specific headers allow hon, to yeh likho:
    // .WithHeaders("Content-Type") // sirf Content-Type header allow hoga
    // .WithHeaders("Authorization") // sirf Authorization header allow hoga
    .AllowAnyHeader() // <-- Ye har header allow karega (Authorization, Content-Type, etc.)

    // Agar tum frontend se cookies ya JWT bhejna chahte ho to ye enable karo
    .AllowCredentials()

    //  SetIsOriginAllowed => true ka matlab har origin allow hoga (localhost, vercel, netlify, etc.)
    //  Ye sirf development mein theek hai — production mein risky hai!
    .SetIsOriginAllowed(origin => true)

    // Safer option (production) ke liye specific frontend origin likho:
    // .WithOrigins("http://localhost:3000") // React dev server
    // .WithOrigins("https://your-frontend.com") // deployed frontend site
);












------------------------------------------------------------------------------------------
sorting
------------------------------------------------------------------------------------------
- to sort data ascending,descending

1. QueryObject.cs
------------------
public class QueryObject
{
    public string? SortBy { get; set; } = null;       // Kis field par sorting honi hai
    public bool IsDescending { get; set; } = false;   // Ascending ya Descending
}

2. IStockRepository.cs
-----------------------
Task<List<Stock>> GetAllAsync(QueryObject query);

3. StockRepository.cs
----------------------
public async Task<List<Stock>> GetAllAsync(QueryObject query)
{
    var stocks = _context.Stocks.Include(c => c.Comments).AsQueryable();

    // Sorting logic
    if (!string.IsNullOrWhiteSpace(query.SortBy))
    {
        if (query.SortBy.Equals("Symbol", StringComparison.OrdinalIgnoreCase))
        {
            stocks = query.IsDescending
                ? stocks.OrderByDescending(s => s.Symbol)
                : stocks.OrderBy(s => s.Symbol);
        }
        else if (query.SortBy.Equals("CompanyName", StringComparison.OrdinalIgnoreCase))
        {
            stocks = query.IsDescending
                ? stocks.OrderByDescending(s => s.CompanyName)
                : stocks.OrderBy(s => s.CompanyName);
        }
        // Yahan aur fields add ki ja sakti hain jaise MarketCap, LastDiv
    }

    return await stocks.ToListAsync();
}

4. StockController.cs
-----------------------
[HttpGet]
public async Task<IActionResult> GetAll([FromQuery] QueryObject query)
{
    var stocks = await _stockRepository.GetAllAsync(query);
    var stockDto = stocks.Select(s => s.ToStockDto()).ToList();
    return Ok(stockDto);
}

5. Test Instructions (Browser, Swagger, Postman)
--------------------------------------------------
GET /api/stock?SortBy=Symbol&IsDescending=false     -> Symbol ascending
GET /api/stock?SortBy=Symbol&IsDescending=true      -> Symbol descending

GET /api/stock?SortBy=CompanyName&IsDescending=false  -> CompanyName ascending
GET /api/stock?SortBy=CompanyName&IsDescending=true   -> CompanyName descending

------------------------------------------------------------------------------------------
pagination
------------------------------------------------------------------------------------------

What is Pagination?
-------------------
Pagination ka matlab hota hai data ko chhote chhote pages mein divide karna. Jab database mein bohot zyada records hoon (e.g. 1000+ stocks), to sab data ek hi request mein bhejna slow aur inefficient hota hai. 

Isliye, hum pagination use karte hain taake:
- Har request mein sirf limited items (e.g. 10, 20) hi aayein
- Application fast chale
- User easily next/previous pages pe navigate kar sake

--------------------------------------------------------

1. QueryObject.cs (Helper Class)

namespace StockPlaform.Helpers
{
    public class QueryObject
    {
        public string? CompanyName { get; set; }
        public string? Symbol { get; set; }

        public string? SortBy { get; set; }
        public bool IsDescending { get; set; }

        public int PageNumber { get; set; } = 1;
        public int PageSize { get; set; } = 20; // Har page par maximum 20 records
    }
}

--------------------------------------------------------

* also update Interface 

2. StockRepository.cs - GetAllAsync Method

public async Task<List<Stock>> GetAllAsync(Q*eryObject query)
{
    var stocks = _context.Stocks.Include(c => c.Comments).AsQueryable();

    // Filtering (optional)
    if (!string.IsNullOrEmpty(query.CompanyName))
    {
        stocks = stocks.Where(s => s.CompanyName.Contains(query.CompanyName));
    }

    if (!string.IsNullOrEmpty(query.Symbol))
    {
        stocks = stocks.Where(s => s.Symbol.Contains(query.Symbol));
    }

    // Sorting (optional)
    if (!string.IsNullOrWhiteSpace(query.SortBy))
    {
        if (query.SortBy.Equals("Symbol", StringComparison.OrdinalIgnoreCase))
        {
            stocks = query.IsDescending
                ? stocks.OrderByDescending(s => s.Symbol)
                : stocks.OrderBy(s => s.Symbol);
        }
        else if (query.SortBy.Equals("CompanyName", StringComparison.OrdinalIgnoreCase))
        {
            stocks = query.IsDescending
                ? stocks.OrderByDescending(s => s.CompanyName)
                : stocks.OrderBy(s => s.CompanyName);
        }
    }

    // Pagination
    var skipNumber = (query.PageNumber - 1) * query.PageSize;
    return await stocks.Skip(skipNumber).Take(query.PageSize).ToListAsync();
}

--------------------------------------------------------

3. How Pagination Works

Formula:
Skip = (PageNumber - 1) * PageSize

Example:
PageNumber = 1, PageSize = 20 => Skip(0), Take(20)
PageNumber = 2, PageSize = 20 => Skip(20), Take(20)
PageNumber = 3, PageSize = 10 => Skip(20), Take(10)

Yani har page ke liye hum kuch records "skip" karte hain aur "take" karte hain jitni quantity chahiye hoti hai.

--------------------------------------------------------

4. Sample API Call

GET /api/stock?CompanyName=Apple&PageNumber=2&PageSize=10

- CompanyName filter karega sirf "Apple" wale stocks
- Page 2 ka data milega (10 records per page)
- Backend skip karega 10 records aur next 10 return karega

--------------------------------------------------------


Total Records in DB = 40

Test Case 1:
GET /api/stock?PageNumber=1&PageSize=10
Skip = (1 - 1) * 10 = 0
Take = 10
Returned Records: 1 to 10

Test Case 2:
GET /api/stock?PageNumber=2&PageSize=10
Skip = (2 - 1) * 10 = 10
Take = 10
Returned Records: 11 to 20

Test Case 3:
GET /api/stock?PageNumber=4&PageSize=10
Skip = (4 - 1) * 10 = 30
Take = 10
Returned Records: 31 to 40

------------------------------------------------------------------------------------------
JWT + IDENTITY
------------------------------------------------------------------------------------------
for identity + jwt authentication in ASP.NET Core

Basic setup

===============================================================================
GOAL:
-----
- User login/register system (using Identity)
- JWT token issue karna login pe
- APIs ko secure karna using [Authorize] + JWT

===============================================================================
Step 1: Install Required Packages
---------------------------------
Yeh 3 NuGet packages install karo:

1. Microsoft.Extensions.Identity.Core
   -> Identity ka base system enable karta hai.

2. Microsoft.AspNetCore.Identity.EntityFrameworkCore
   -> Identity ko Entity Framework ke saath connect karta hai.

3. Microsoft.AspNetCore.Authentication.JwtBearer
   -> JWT token ko app mein handle karta hai.

Yeh tino packages **har project mein chahiye hote hain** jab JWT + Identity use kar rahe ho.

===============================================================================
Step 2: Create AppUser Model
-----------------------------
public class AppUser : IdentityUser { }

Matlab: 
ASP.NET ka built-in `IdentityUser` inherit karna hai aur `AppUser` naam ka apna custom user class banana hai.  
Custom fields future mein yahan add kar sakte ho (e.g. FullName, Role, etc.).

Yeh step har project mein hota hai.

===============================================================================
Step 3: Modify ApplicationDbContext
-----------------------------------
Replace:
    public class ApplicationDbContext : DbContext

With:
    public class ApplicationDbContext : IdentityDbContext<AppUser>

Matlab:
Ab aapka database sirf Stocks, Comments jese models nahi, balkay Identity ke Users, Roles, Tokens waghera bhi handle karega.

===============================================================================
Step 4: Configure Identity + JWT in Program.cs
----------------------------------------------

1. Identity Configuration:

in program.cs

builder.Services.AddIdentity<AppUser, IdentityRole>(options =>
{
    //this code change according to needs 
    options.Password.RequireDigit = true;
    options.Password.RequireLowercase = true;
    options.Password.RequireUppercase = true;
    options.Password.RequireNonAlphanumeric = true;
    options.Password.RequiredLength = 12;
}).AddEntityFrameworkStores<ApplicationDBContext>();

* you can use other options

Yeh Identity service ko enable karta hai aur batata hai ke data store kaha hoga (ApplicationDbContext).

2. JWT Configuration:

builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidIssuer = builder.Configuration["JWT:Issuer"],
        ValidateAudience = true,
        ValidAudience = builder.Configuration["JWT:Audience"],
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(builder.Configuration["JWT:Key"]))
    };
});

Matlab:
Yeh batata hai ke JWT token kaise validate hoga:
- Kon bana raha hai token? (Issuer)
- Kon use kar raha hai? (Audience)
- Kya token sahi se sign hua hai? (Key)

===============================================================================
Step 5: appsettings.json mein JWT section add karo
---------------------------------------------------
"JWT": {
  "Key": "swordfish", your jwt secret
  "Issuer": "https://localhost:7165", or your domain name
  "Audience": "https://localhost:7165"
}

Yeh woh config values hain jo JWT token generate aur validate karte waqt use hoti hain. 
Yeh values tumhare project ke hisaab se change hongi.

===============================================================================
Step 6: Add Middleware in Program.cs
-------------------------------------
app.UseAuthentication();
app.UseAuthorization();

Matlab:
Har incoming request ke liye pehle check hoga ke user JWT token ke through authenticated hai ya nahi, 
phir uske authorization rights dekhe jayenge.

===============================================================================
Step 7: Create Migration and Update Database
--------------------------------------------
Command Line se:
> dotnet ef migrations add InitialIdentityMigration
> dotnet ef database update

Ya Visual Studio ke Package Manager Console se:
> Add-Migration InitialIdentityMigration
> Update-Database

Matlab:
Yeh step sab required Identity aur tumhare custom tables ko DB mein create karta hai.

===============================================================================
Summary: Reusable vs Custom Code
---------------------------------

REUSABLE (Har Project mein reuse hota hai):
- Identity & JWT packages
- AppUser class (structure same, fields may change)
- IdentityDbContext usage
- Identity & JWT setup in Program.cs
- app.UseAuthentication(), app.UseAuthorization()
- Migration flow

PROJECT-SPECIFIC (Har Project mein alag hota hai):
- JWT key, issuer, audience (appsettings.json)
- AppUser custom properties (like FullName)
- Password policy configuration
- Tumhare models jaise Stock, Comment etc.




===============================================================================
ASP.NET Core Web API – Identity + JWT (AccountController Setup + Roles) 
---------------------------------

Register & Login ke liye controller banao

step 1:  
create new controller eg: Account controller  
🔹 Yahan hum ek naya controller bana rahe hain jiska naam AccountController hoga. Ye controller register aur login ka kaam karega.

step 2:  
inject the usermodel like below  

public class AccountController : ControllerBase
{
    private readonly UserManager<AppUser> _userManager;

    public AccountController(UserManager<AppUser> userManager)
    {
        _userManager = userManager;
    }
}

- Yahan hum Identity ka UserManager<AppUser> inject kar rahe hain jo user create, delete, find jaise operations handle karta hai.  
- AppUser tumhara custom user model hai jo IdentityUser se inherit karta hai.  
- <AppUser> -> tumhara user model  
- UserManager -> Identity ka built-in helper class jo user related logic handle karta hai

step 3:  
add post routes  
-> you can use dtos , go and create dtos and use in AccountController.cs  
-> check AccountController.cs for details  
-> check Account > RegisterRequestDto.cs for details  
-> check Mappers > AccountMappers.cs for details  

- Yahan tum controller mein POST method banaoge jisme user registration ya login ka logic hoga.  
- Hum DTOs ka use karte hain taake request aur response ko model se separate rakhein — cleaner aur reusable banane ke liye.  
- RegisterRequestDto ek class hai jo registration request ka data hold karegi (jaise email, username, password).

step 4:  
define roles  
-> we are using roles becauses we want to restrict access to some apis if we not use roles anyone can access all apis  
-> because in program.cs we define roles IdentityRole so we need to create roles  

- Yahan hum roles define kar rahe hain (User, Admin, Manager) taake har user ko specific access mil sake.  
- Har koi har API access na kar sake is wajah se roles use karna important hota hai.  
- Program.cs mein hum ne AddIdentity<AppUser, IdentityRole>() likha tha, to humein IdentityRole ke roles bhi create karne padenge.

-> in ApplicationDbContext.cs Seed Roles

protected override void OnModelCreating(ModelBuilder builder)
{
    base.OnModelCreating(builder);

    var roles = new List<IdentityRole>
    {
        new IdentityRole
        {
            Name = "User",
            NormalizedName = "USER"
        },
        new IdentityRole
        {
            Name = "Admin",
            NormalizedName = "ADMIN"
        }
    };

    builder.Entity<IdentityRole>().HasData(roles);
}

- Yeh code ApplicationDbContext mein likhna hota hai. Yeh Seed ka kaam karega — yani pehle se DB mein 3 roles add kar dega: User, Admin, Manager.  
- HasData() ka matlab hota hai ke yeh data migration ke through DB mein seed ho jayega.

step 4:  
migrations to seed  

> dotnet ef migrations add SeedRoles  
> dotnet ef database update  
// or in Visual Studio Package Manager Console  
> Add-Migration SeedRoles  
> Update-Database

- Ab jab roles ka code likh liya hai, usko database mein apply karne ke liye Migration banani hogi.  
- Migration ka matlab hota hai database ko update karne ka process taake naye roles add ho jayein.

step 5:  
add users using swagger  

- Ab tum Swagger se POST /api/account/register ka use karke naye users bana sakte ho, jinko roles assign ho sakte hain.  

step 6:
- check kro kya roles sahi se assign hue hain ya nahi.
-users aye dbo.AspNetUsers




--------------------------------------------------------
now create claims for jwt token 

JWT Claims – Simple Explanation

📌 What are Claims?
Claims = JWT token ke andar chhupi user info.
API ko batata hai: ye user kaun hai, kya kar sakta hai.

Example Claims (token ke andar):
{
  "sub": "a1b2c3",              // user id
  "email": "user@gmail.com",
  "role": "Admin",
  "FullName": "Shazeel Khan",
  "exp": 1720000000             // expiry time
}

 Common Claims:
- sub       → Subject (User ID)
- email     → User’s email
- role      → User’s role (Admin/User)
- exp       → Expiry timestamp
- FullName  → (Custom) User's name

JWT Flow with Claims:
1. Login → user verified
2. List<Claim> banti hai
3. JWT token generate hota hai with claims
4. Client ko token milta hai
5. Har request mein token bheja jata hai
6. API token read karke access verify karti hai


📦 Repository → sirf database ka kaam karta hai (CRUD).  
⚙️ Service → business logic handle karta hai (login, register, JWT, roles).  
Repository = data uthana/saving  
Service = decision lena, process karna 

--------------------------------------------------------
step 1: create interface for service
check ITokenService.cs for details inside it we create a method to create token

step 2: create service class
check TokenService.cs for details
inhertit ITokenService and implement the method to create token

step:3 
// register Token service in program.cs via DI
builder.Services.AddScoped<ITokenService, TokenService>();

step 4:  create dto
check Dtos> Account> NewUserDto.cs for Details

step 5: inject ItokenService in AccountController.cs

step 6: cretae mapper 
 public static NewUserDto ToNewUserDto(this AppUser user, string token)
        {
            return new NewUserDto
            {
                UserName = user.UserName,
                Email = user.Email,
                Token = token
            };
        }
step 7: use mapper in controller 
if (roleResult.Succeeded)
                    {
                        // Generate JWT token for the new user
                        var token =  _tokenService.CreateToken(appUser);

                        // Use mapper to convert to NewUserDto
                        var newUserDto = appUser.ToNewUserDto(token);

                        return Ok(newUserDto);
                    }

step 8: test now in 
/api/account/register it should return token


--------------------------------------------------------
now create login functionality 
step 1: create dto for login
check Dtos > Account > LoginRequestDto.cs for details

step 2: add login method in AccountController.cs
check AccountController.cs for details
step 3: inject SignInManager in AccountController.cs

step 4: create dto check Dtos > Account > LoginResponseDto.cs for details
step 5: use mapper to convert to LoginResponseDto
check Mappers > AccountMappers.cs for details
step 6: put swagger configuration in Program.cs for jwt

builder.Services.AddSwaggerGen(option =>
{
    option.SwaggerDoc("v1", new OpenApiInfo { Title = "Demo API", Version = "v1" });
    option.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        In = ParameterLocation.Header,
        Description = "Please enter a valid token",
        Name = "Authorization",
        Type = SecuritySchemeType.Http,
        BearerFormat = "JWT",
        Scheme = "Bearer"
    });
    option.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type=ReferenceType.SecurityScheme,
                    Id="Bearer"
                }
            },
            new string[]{}
        }
    });
});


a authorize button in swagger to test login

step 7: put [Authorize] attribute on the controller or specific methods you want to secure
step 8: testing 
 -> create account using register api
 -> login using login api it will give you token 
 -> copy that token
 -> go to swagger and click on authorize button
 -> paste the token in the input field
 -> now you can access the secured APIs
 note if you [Authorize] secured API without token it will give you 401 unauthorized error

 --------------------------------------------------------------------------------------
 Data Seeding through third party api
 --------------------------------------------------------------------------------------

 we need to create stocks instead of creating all by ourselves 
we can use api to create stocks 
-> make service to find data from FMP api
-> return data in form of stock model

step 1:
create IFMPServicein Interfaces folder
step 2 :
create FMPService in Services folder that implements IFMPService
check FMPService for details

step 3 : 
register FmpKey in appsettings.json file

step 4:
Dto > create FMPStock.cs
use data from api to create model using edit > paste special > paste json as class

step 5:
create Mappers > StockMapper.cs
inside check ToStockFromCreateDto for details

step 6 : 
register FMPService in Program.cs
services.AddScoped<IFMPService, FMPService>();
builder.Services.AddHttpClient<IFMPService, FMPService>();

Step 7:

1. Check our db

2. If stock already exists

3. If stock does not exists, seed data

4. Create comment/portfolio


-> modify CommentController to use FMPService
-> inject FMPService in CommentController
-> make changes in Create IActionMethod

step 8:
-> modify PortfolioController to use FMPService
-> inject FMPService in PortfolioController
-> check AddPortfolio IActionMethod

step 9:
test 
adding stock through symbol in portfolio i will fetch data from FMPService and add stock to portfolio

------------------------------------------------------------------------------------------
Relationships
------------------------------------------------------------------------------------------
- one to many











